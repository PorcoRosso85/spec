---
status: Accepted
date: 2025-11-02 JST
scope: repo全体
introduces:
  - catalog/
  - adr/
  - skeleton/
ci_guard_scope: structure-only
human_review_scope: spec/impl fit と ビジネス価値
---

# 1人と AI 体制で壊さず拡張し続けるための 3 SSOT と CI 境界

## 1. 背景
開発は自分と AI で進む。
思いついた改善や新機能をその場で直接コードに入れると 責務の境界があいまいなまま肥大しやすい。
いったん境界がにじむと 後から元に戻すのはほぼ不可能になる。
半年後の自分は なぜそうしたか を忘れるので 同じ失敗をもう一度繰り返す危険がある。
最悪パターンは 本番を壊せるのは自分だけなのに 自分でもどこを触ると壊れるか分からない という状態で それは売上停止リスクになる。

この ADR は その崩壊パターンを構造で防ぐ。

## 2. 目的

2.1 追加や変更を自由に積めるようにしたい
ただし勝手な肥大や責務のにじみは物理的に禁止したい

2.2 いまこの瞬間の正しいシステム構成 と なぜその形なのか の両方を常に説明できるようにしたい
どこを読めばいいか一発で示せるようにしたい

2.3 将来の自分や 途中から入る人が 最小限の資料で安全に引き継げるようにしたい
どこを直すときに どこを壊さないべきかを判断できるようにしたい

2.4 AI を使って開発速度を上げても AI が勝手に足した責務が本線に混ざらないようにしたい

2.5 規制 監査 要求トレースを あとから言い訳で作るのではなく 日常の更新ログそのものからすぐ出せるようにしたい

## 3. 決定

このリポジトリでは 正 を三つに分けて管理し 混ぜない
役割をはっきり分ける

### 3.1 カタログ catalog

定義
取り得る責務スロットの全集合のカタログ
各スロット id 安定 id
そのスロットが担う責務 一文
オーナー一人
依存先 他スロット id
満たすべき要求やリスク
external 系の責務も同じ棚で扱う

スロット id は
area.path.with.more.dots
のような形式
area は security tenant platform external などの固定プレフィクス
path.with.more.dots は auth.repo.secrets のように任意深さ

active な葉スロットだけが 実際の責務を持つ単位になる
中間ノード security.auth のような抽象スロットはあってよいが それ自体を直接実装責務にはしない

これは どんな引き出しが存在し得るか その引き出しは何を担当できるか の SSOT
カタログに無い責務スロットは不正として CI でブロックされる
勝手に新しい箱は作れない

### 3.2 ADR adr

定義
カタログから どのスロットを今回使うか どこへ移譲するか なぜそうしたか を時系列で残すログ
採用 再配置 廃止 の意思決定記録

例
監査ログ責務を security.audit.accountability から external.idp.auth に移さない理由
tenant.billing.metering を追加する理由とビジネス背景

ADR なしでは 新しいスロットをプロダクトに採用してはいけない
ADR は なぜこの構成であるべきか の公式な説明責任レコード

ADR 同士は時系列で積み上がる
カタログのスロット定義と矛盾する変更は CI で拒否される

ADR は なぜそうなったのか という意思決定の SSOT
のちの自分が どこをどこまで戻してよいかを判断する土台になる

### 3.3 スケルトン skeleton

定義
その時点で実際に採用するスロットだけを並べ どのディレクトリ どのサービス どのレイヤにどう割り当てるかを確定した構成スナップショット
これは今回のこのプロダクトの形を一つに固定したもの
実装チケットの入口
実際に触ってよい境界

スケルトンは カタログ と 最新の ADR を元に生成される
両方そろっていないなら スケルトンは作れない

スケルトンが出て初めて spec や I O 契約を作り 実装を始めてよい
スケルトンが無いなら いまの形がまだ固まっていないので 実装は禁止

スケルトンは いま動かすべき形 の SSOT

### 3.4 CI の責務

CI は 三つの正 が矛盾しないことだけを見る

カタログ側チェック
スロット id 形式が正しいか
responsibility が一文一責務になっているか
owner が一人だけか active スロットでは必須
dependsOn が全て有効なスロットを指しているか 循環や自己依存を最低限禁止
external 系も同じ扱い

ADR 側チェック
スケルトンで採用しているスロットは どこかの ADR で採用 移譲 維持 が正当化されていること
誰も決めていないのに勝手に入ったスロットを許さない

スケルトン側チェック
スケルトンに載っている割り当てやディレクトリ構成が 全部カタログ上の active な葉スロットに対応していること
スケルトンに出ていない責務ディレクトリが PR で勝手に増えていないこと

CI がやらないことも明示する
spec と impl の乖離チェックはやらない それは人間が見る
この分割は過剰では という美しさは見ない
ビジネス価値は見ない
PoC の残骸検知は将来の別系統に任せる

つまり CI は 構造の正当性 だけを見る
感性や戦略やコスト優先度までは口を出さない

## 4. 効果

4.1 自由に積めるが 勝手に肥大しない
何かを増やしたければ まずカタログにスロットを定義し ADR で採用判断を書き スケルトンに出す必要がある
どこにも属していない闇の責務はプロダクトに入れられない CI で止まる

4.2 いま何が正しいかを一発で指せる
この責務は誰が持っているか どこに置いてあるか なぜそうなったか に
カタログ スケルトン ADR の三本で即答できる

4.3 過去の自分が未来の自分を守る
ADR の時系列が なぜ のログになるので
将来リファクタする時に どこを巻き戻してよいか どこは壊しちゃいけないかがわかる
なんとなく壊す ではなく 正当に巻き戻す 移す になる

4.4 AI を安全に使える
AI には このスロットだけやれ と指示できる
そのスロット外に勝手に責務を追加しようとしたら カタログにもスケルトンにもないので CI で落ちる
AI は境界内の作業者として扱える

4.5 監査や外部説明も標準で通せる
カタログのスロットごとに どの要求を満たすか どの証跡があるかをひも付ける
スケルトンは その要求をどこで守るかという実体配置を示す
ADR は なぜそこに置くと決めたか を示す
これで規制対応 書類説明 監査回答がほぼそのまま出せる

## 5. 対象外

SLO 達成状況や 障害対応手順は ops 側の運用ルールで扱う
その機能がビジネス的に本当に必要か は経営判断であり CI の外
tree はもっと小さくできたのでは という設計美はあえて人間レビューに残す

## 6. 拡張と禁止事項

この ADR は この三層 catalog adr skeleton を飛ばして直接 src を触る PR を禁止する
破る場合は この ADR を明示的に supersede する新しい ADR をまず追加しなければならない
それなしの直修正 PR はレビュー対象外とする
