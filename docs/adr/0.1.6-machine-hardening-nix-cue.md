# ADR 0.1.6: 機械的堅牢化（Nix×CUE）

## 背景 / ゴール

- vendor を 1本化する。
- 人の運用ルールではなく Nix と CUE だけで機械的に保証する。
- SRP / SOLID / YAGNI / KISS / DRY を守りつつ最小セットだけ導入する。
- main へのマージ後、このルールに沿った spec/** ツリーと CI が順次入っていく前提。

## 決定内容

1. 出力契約の最小化
   - 各 specification/**/flake.nix は以下だけを必須とする。
     1. `packages.${system}.cueModule` : 純CUEツリーをNixがビルドした結果。
     2. `apps.vendor` : cue.mod/pkg/<module> へ symlink/copy する vendor 出力。
     3. `devShells.${system}.default` : 固定バージョンの cue CLI。
   - 任意の `meta.cueModulePath` で import 文字列を宣言してもよい。

2. ピュア入力の担保
   - `nix flake lock --check` / `nix flake check` をゲートにする。
   - `inputs.*.type = "path"` を禁止し、pin 不能な依存を排除する。
   - 許可する fetch 元は github / git+ssh / git+https のみ。

3. CUE 健全性ゲート
   - `cue fmt -n` / `cue vet -c` / `cue eval -c` を devShell 上で走らせる。
   - 相対 import ("./", "../") を検出したら失敗。

4. モジュール名の一意整合チェック
   - `meta.cueModulePath` と `cue.mod/module.cue` の `module:` を一致させる。
   - `packages.*.cueModule` の直下を import できることをスモークテストする。

5. ベンダリングのスモーク
   - 一時ディレクトリに仮想 consumer を生成。
   - symlink モード (`apps.vendor --mode=symlink`) / copy モード (`apps.vendor --mode=copy`) の両方で vendor した上で `cue eval` が通るかを見る。
   - どちらか片方でも壊れたら即 Fail。

6. 再現性ハッシュ
   - cueModule の NAR ハッシュ (`nix hash`) を取る。
   - 同じ flake を再ビルドして NAR ハッシュがズレたら Fail。

7. 対応プラットフォーム行列の最小化
   - `x86_64-linux` と `aarch64-darwin` の 2 つだけをサポート対象にする。
   - どちらか欠けていたら Fail。増やさない (YAGNI)。

8. 自動インデックス生成
   - `nix run .#index` で machine-readable な `specification/index.json` を生成する。
     - `{ name, modulePath, rev, narHash }` を列挙。
   - 生成物に差分があるのにコミットされていなければ Fail。重複した手書きメタ情報を排除 (DRY)。

9. エラーUXの機械化
   - `apps.vendor` に `--dry-run` / `--mode=symlink|copy` / 上書き検知を持たせる。
   - 失敗時は「次の1手」(例: 正しい import 例 / 期待するパス) を必ず表示する。

10. 互換性チェックの最小化 (オプトイン)
   - `PUBLIC.cue` がある spec だけ `cue diff` で公開面の互換性を見る。
   - PUBLIC.cue が無ければスキップ。やらない勇気 (YAGNI)。

11. CI チェックの順序と最小セット
   1. lock/purity (ピュア性, 上記2)
   2. CUE健全性 (上記3)
   3. module整合 (上記4)
   4. vendorスモーク (上記5)
   5. 再現性ハッシュ (上記6)
   6. systems行列 (上記7)
   7. index生成 (上記8)

   - すべて Nix derivation または `nix develop -c ...` で走らせる。外部ツール前提は禁止。

12. ツリー構造

repo-root/
├─ docs/
│   ├─ adr/
│   │   └─ 0.1.6-machine-hardening-nix-cue.md  # このADR
│   └─ structure/
│       └─ index.md                           # リポジトリ構造と責務の説明 (本ドキュメント系)
│
├─ specification/                             # すべての provider/spec をカタログ化
│   ├─ index.json                             # 自動生成される機械可読インデックス
│   ├─ README.md                              # 運用ルール/契約の概要
│   └─ example-layer/                         # 例: ddd-layer 相当の名前
│       └─ example-spec/                      # 例: spec名
│           ├─ flake.nix                      # cueModule / apps.vendor / devShells をエクスポート
│           ├─ cue/                           # provider側の純CUEソース
│           │   └─ .keep                      # ディレクトリ保持用
│           └─ checks/                        # このspec固有の健全性/スモーク
│               └─ README.md                  # 失敗条件の説明 (Nixから呼ぶ想定)

13. 導入段階
   - Phase A: 出力契約(2)・CUE健全性(3)・vendorスモーク(5) をまず守る。
   - Phase B: ピュア入力(2のlock/purity側)・モジュール整合(4)・2プラットフォーム行列(7)。
   - Phase C: 再現性ハッシュ(6)・index自動生成(8)・エラーUX(9)。
   - Opt-in: 公開互換性チェック(10)。

## 結論

- spec は "書いたらそのまま vendoring できる" ことを機械的に約束する。
- ルールは flake.nix と Nix CI に埋め込む。人間の口約束は禁止。
- これにより、"増やさない (YAGNI) / 単純に (KISS) / 重複しない (DRY)" を保ったまま壊れにくい供給契約を提供できる。
