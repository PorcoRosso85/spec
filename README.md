# spec

Repository for system specifications with 3-SSOT guard enforcement.

## Quick Start: Adding New Responsibilities

This repository enforces a 3-step process for any structural change:

### 1. Catalog → Define the responsibility slot

Add a new slot to `docs/catalog/slots/*.cue`:

```cue
slots: {
  "custom.my-new-feature": schema.#Slot & {
    id:             "custom.my-new-feature"
    responsibility: "Single-sentence description of what this does"
    status:         "abstract"  // Start as abstract
    tier:           "app"       // or "business" / "infra"
    dependsOn: []
    standardRef: []
  }
}
```

### 2. ADR → Justify and activate

Create `docs/adr/adr-NNNN.cue` to activate the slot:

```cue
package adr

adrNNNN: {
  id:    "NNNN"
  title: "Activate my-new-feature"
  status: "accepted"
  date:  "2025-11-03"

  background: """
    Why this responsibility is needed...
    """

  decision: """
    We are activating custom.my-new-feature...
    """

  activations: [{
    slotId:    "custom.my-new-feature"
    owner:     "your-name"
    placement: "apps/my-feature/"
    rationale: "Placement justification..."
  }]
}
```

### 3. Skeleton → Declare placement (Auto-generated)

**Option A: Automatic (Recommended)**

Run the generator:

```bash
./scripts/gen_skeleton_from_adr.sh
```

This reads all ADR activations and generates `skeleton.generated.json`. Review and apply:

```bash
cp docs/structure/.gen/skeleton.generated.json docs/structure/.gen/skeleton.json
git add docs/structure/.gen/skeleton.json
```

**Option B: Manual**

Update `docs/structure/.gen/skeleton.json` directly:

```json
{
  "custom.my-new-feature": "apps/my-feature/"
}
```

**Now you can add code in `apps/my-feature/`**. Any other location will be rejected by CI.

---

## Structure

- **`docs/catalog/`** - Slot catalog (SSOT #1: what responsibilities exist)
  - `schema/*.cue` - Slot type definitions
  - `slots/*.cue` - Actual slot definitions
  - `slot-catalog.cue` - Aggregated catalog

- **`docs/adr/`** - Architecture Decision Records (SSOT #2: why we use which slots)
  - `adr-*.cue` - ADRs in CUE format (machine-readable)
  - `.gen/adr-*.md` - Generated Markdown (DO NOT EDIT)

- **`docs/structure/.gen/`** - Current configuration (SSOT #3: where slots are placed)
  - `skeleton.json` - Authorized directory placement map
  - `traceability.json` - Auto-generated traceability (DO NOT EDIT)

- **`scripts/`** - Generation and validation scripts
  - `gen_skeleton_from_adr.sh` - Generate skeleton.json from ADR activations
  - `gen_adr_md.sh` - Generate Markdown from CUE ADRs
  - `gen_traceability.sh` - Generate traceability.json
  - `check_skeleton_guard.sh` - Validate path authorizations

---

## Boundary & Scope

This repository strictly enforces a boundary between design/contract and implementation:

### In Scope (This Repository)
- **Catalog** (`docs/catalog/**`) - Responsibility slot definitions
- **ADR** (`docs/adr/**`) - Architecture decision records
- **Skeleton** (`docs/structure/.gen/skeleton.json`) - Authorized placement map
- **Specification** (`specification/**/flake.nix`) - Contract attributes only
- **External Reference Validation** - Non-build checks for external flake health

### Out of Scope (External Repositories)
- **Implementation directories**: `apps/`, `infra/`, `domain/`
- **Build, test, and distribution** of actual code
- **Runtime operations**

> CI enforces this boundary via **skeleton-guard**, which detects out-of-scope changes and suggests migration to external repositories.

### External References
Starting from skeleton version 0.2.0, this repository supports **external flake references**:
- Implementation code lives in external repositories
- This repo validates reference health (resolvability, pinned revisions, contract attributes)
- No builds or tests run in this repository

---

## CI Validation

Every PR is checked by 5 jobs:

1. **catalog-validate** - Validates slot definitions, dependencies, and naming
2. **adr-validate** - Validates ADR-skeleton alignment
3. **skeleton-guard** - Prevents unauthorized directory additions
4. **skeleton-gen** - Verifies skeleton.json matches ADR activations (observation mode)
5. **traceability-gen** - Regenerates and validates traceability.json (observation mode)

**Phase-0+1**: All checks run in observation mode (`continue-on-error: true`)

**Phase-3**: Enforcement mode - PRs cannot merge if checks fail

---

## Local Development

### Install CUE (optional)

```bash
curl -fsSL https://cuelang.org/install.sh | sh
```

### Validate locally

```bash
# Validate catalog
cd docs/catalog && cue vet ./...

# Generate skeleton from ADRs
./scripts/gen_skeleton_from_adr.sh

# Generate ADR Markdown
./scripts/gen_adr_md.sh

# Generate traceability
./scripts/gen_traceability.sh

# Check skeleton guard
./scripts/check_skeleton_guard.sh
```

---

## Rules

1. **Never edit `.gen/` files manually** - They are auto-generated by CI
2. **Always follow the 3-step process** - catalog → ADR → skeleton (auto-generated)
3. **Use skeleton generator** - `./scripts/gen_skeleton_from_adr.sh` to sync skeleton.json
4. **One slot = One responsibility** (SRP - Single Responsibility Principle)
5. **One slot = One owner** - Clear accountability
6. **No circular dependencies** - Validated by CI

---

## Documentation

- [Structure Overview](docs/structure/index.md)
- [ADR: 3-SSOT System](docs/adr/adr-1人AI体制で壊さず拡張し続ける2.md)
- [Operations Guide](docs/ops/index.md)

---

## Branch Protection

After the first CI run, configure branch protection:

1. GitHub Settings → Branches → Add rule for `main`
2. Enable: "Require status checks to pass before merging"
3. Select required checks:
   - `catalog-validate`
   - `adr-validate`
   - `skeleton-guard`
   - `traceability-gen`

See: [Branch Protection Setup](docs/ops/branch-protection.md)
