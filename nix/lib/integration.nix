# Integration test utilities for Phase 6 (Integration-RED)
# Purpose: Extract real data from spec-repo (feats, spec keys, etc.) and generate CUE files
# Design: Nix-only (no shell logic), uses builtins.readDir / cue eval for extraction

{ pkgs, self, cue }:

let
  # Import CUE module utilities
  cueModule = import ./cue-module.nix { inherit pkgs self; };
  
  # Helper: List all feat directories
  # Returns: [ "spec", "decide-ci-score-matrix", ... ]
  listFeatDirs = 
    let
      featRoot = "${self}/spec/urn/feat";
      entries = builtins.readDir featRoot;
      # Filter only directories
      dirs = builtins.filter 
        (name: entries.${name} == "directory")
        (builtins.attrNames entries);
    in dirs;
  
  # Helper: Extract feat metadata (id, slug) from a feat directory
  # Input: feat directory name (e.g., "spec")
  # Output: { id = "urn:feat:spec"; slug = "spec"; }
  extractFeatMeta = featDir:
    let
      # Path to feature.cue
      featFile = "${self}/spec/urn/feat/${featDir}/feature.cue";
      
      # Use CUE to evaluate and extract to JSON
      # Note: This requires CUE eval, which we'll do via derivation
      # For now, we'll use a simple pattern match on slug
      # (id is derived as "urn:feat:<slug>")
      
      # Read feature.cue content
      content = builtins.readFile featFile;
      
      # Extract slug using regex
      # Pattern: slug: "..."
      slugMatch = builtins.match ".*slug:[[:space:]]*\"([^\"]+)\".*" content;
      
      slug = 
        if slugMatch != null && builtins.length slugMatch > 0
        then builtins.head slugMatch
        else throw "Failed to extract slug from ${featFile}";
      
      id = "urn:feat:${slug}";
    in {
      inherit id slug;
    };
  
  # Helper: Extract all feats as list of {id, slug}
  # Returns: [ { id = "urn:feat:spec"; slug = "spec"; } ... ]
  extractAllFeats =
    let
      featDirs = listFeatDirs;
      feats = builtins.map extractFeatMeta featDirs;
    in feats;
  
  # Helper: Generate CUE file content for feat list (verify - clean data)
  # Input: list of {id, slug}
  # Output: CUE string defining feat list (no duplicates)
  # Note: Uses 'integrationInput' to avoid CUE scope resolution issues with 'input: input'
  genFeatListVerifyCue = feats:
    let
      # Convert to CUE list format
      featItems = builtins.map (feat: ''
        {
          id: "${feat.id}"
          slug: "${feat.slug}"
        }'') feats;
      
      # Join with commas
      featList = builtins.concatStringsSep ",\n\t\t" featItems;
    in ''
      package integration_verify_04
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Source: spec/urn/feat/* (real data, clean)
      
      integrationInput: det.#UniqInput & {
      	feats: [
      		${featList},
      	]
      	
      	// Sanity guard: Ensure real data is flowing (minimum 2 feats expected)
      	feats: list.MinItems(2)
      }
    '';
  
  # Helper: Generate CUE file with duplicate feat (for DoD4-Negative)
  # Input: list of {id, slug}
  # Output: CUE string with first feat duplicated (malicious injection)
  # Note: Uses 'integrationInput' to avoid scope issues
  genFeatListNegativeCue = feats:
    let
      # Add duplicate of first feat (malicious)
      duplicate = builtins.head feats;
      featsWithDup = feats ++ [ duplicate ];
      
      featItems = builtins.map (feat: ''
        {
          id: "${feat.id}"
          slug: "${feat.slug}"
        }'') featsWithDup;
      
      featList = builtins.concatStringsSep ",\n\t\t" featItems;
      
      # Extract first feat ID for expected value
      firstFeatId = (builtins.head feats).id;
      firstFeatSlug = (builtins.head feats).slug;
    in ''
      package integration_negative_04
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Source: spec/urn/feat/* + intentional duplicate (malicious injection)
      
      integrationInput: det.#UniqInput & {
      	feats: [
      		${featList},
      	]
      	
      	// Sanity guard: Ensure duplicate was injected (minimum 3 items)
      	feats: list.MinItems(3)
      }
    '';
  
  # Helper: Extract spec keys as flattened dotted paths (for DoD2 Consumer API)
  # Input: self.spec attrset
  # Output: [ "spec.cuePath" "spec.schemaPath" "spec.urn.featPath" ... ]
  # Note: Flattens nested attrs with dot notation, prefixed with "spec."
  extractSpecKeys = spec:
    let
      # Check if value is a derivation (has 'type' = "derivation")
      isDerivation = value:
        builtins.isAttrs value && (value.type or null) == "derivation";
      
      # Flatten nested attrset to dotted paths
      flattenAttrs = prefix: attrs:
        builtins.concatMap (key:
          let
            value = attrs.${key};
            newPrefix = if prefix == "" then key else "${prefix}.${key}";
          in
            if builtins.isAttrs value && !(isDerivation value)
            then flattenAttrs newPrefix value
            else [ newPrefix ]
        ) (builtins.attrNames attrs);
      
      # Start with "spec." prefix
      paths = flattenAttrs "spec" spec;
    in paths;
  
  # Helper: Generate CUE file for DoD2 verify (clean data)
  # Input: list of spec keys (e.g., ["spec.cuePath", ...])
  # Output: CUE string with required (SSOT) and actual (self.spec)
  # Design: required uses detector SSOT, actual uses real data
  genConsumerAPIVerifyCue = specKeys:
    let
      # Actual: real data from self.spec
      actualItems = builtins.map (key: ''"${key}"'') specKeys;
      actualList = builtins.concatStringsSep ",\n\t\t" actualItems;
    in ''
      package integration_verify_02
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Design: required uses detector SSOT, actual uses self.spec (real data)
      
      integrationInput: det.#ConsumerAPIInput & {
      	// Required: SSOT from detector (minimum API contract)
      	required: det.#ConsumerAPIMinimumKeys
      	
      	// Actual: self.spec keys (real implementation)
      	actual: [
      		${actualList},
      	]
      	
      	// Sanity guard: Ensure real data is flowing
      	actual: list.MinItems(6)
      }
    '';
  
  # Helper: Generate CUE file for DoD2 negative (missing key)
  # Input: list of spec keys, key to remove (e.g., "spec.urn.envPath")
  # Output: CUE string with required (SSOT) and actual (missing key)
  # Design: required uses detector SSOT, actual has intentional omission
  genConsumerAPINegativeCue = specKeys: missingKey:
    let
      # Actual: all keys except missingKey (malicious injection)
      actualKeys = builtins.filter (key: key != missingKey) specKeys;
      actualItems = builtins.map (key: ''"${key}"'') actualKeys;
      actualList = builtins.concatStringsSep ",\n\t\t" actualItems;
    in ''
      package integration_negative_02
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Design: required uses detector SSOT, actual has intentional missing key
      
      integrationInput: det.#ConsumerAPIInput & {
      	// Required: SSOT from detector (minimum API contract)
      	required: det.#ConsumerAPIMinimumKeys
      	
      	// Actual: self.spec keys with intentional omission (malicious)
      	actual: [
      		${actualList},
      	]
      	
      	// Sanity guard: Ensure missing key was injected
      	actual: list.MinItems(5)
      }
    '';
  
  # Helper: Extract manifest definition from manifest.cue (for DoD3)
  # Output: { version = "0.1.0"; paths = ["cuePath", ...]; }
  extractManifest =
    let
      # Use cue export to get clean JSON (export enforces concrete values)
      # Note: Must run from repo root to access cue.mod/module.cue
      manifestJson = pkgs.runCommand "manifest.json"
        { buildInputs = [ cue ]; }
        ''
          cd ${self}
          ${cue}/bin/cue export ./spec/manifest.cue -e manifest --out json > $out
        '';
      
      manifest = builtins.fromJSON (builtins.readFile manifestJson);
    in {
      version = manifest.version;
      paths = manifest.outputs.paths;
    };
  
  # Helper: Generate CUE file for DoD3 verify (clean data)
  # Input: manifest data, self.spec keys
  # Output: CUE string with expected (manifest) and actual (self.spec)
  genOutputsManifestVerifyCue = manifest: specKeys:
    let
      # Expected: from manifest (SSOT)
      expectedPaths = builtins.map (p: ''"${p}"'') manifest.paths;
      expectedPathsList = builtins.concatStringsSep ",\n\t\t\t" expectedPaths;
      
      # Actual: from self.spec
      actualPaths = builtins.map (p: ''"${p}"'') specKeys;
      actualPathsList = builtins.concatStringsSep ",\n\t\t\t" actualPaths;
      
      # Version
      expectedVersion = manifest.version;
      actualVersion = self.spec.version or "unknown";
    in ''
      package integration_verify_03
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      
      // Auto-generated by nix/lib/integration.nix
      // Design: expected uses manifest.cue (SSOT), actual uses self.spec
      
      integrationInput: det.#OutputsManifestInput & {
      	// Expected: manifest.cue (SSOT)
      	expected: {
      		paths: [
      			${expectedPathsList},
      		]
      		version: "${expectedVersion}"
      	}
      	
      	// Actual: self.spec (public API)
      	actual: {
      		paths: [
      			${actualPathsList},
      		]
      		version: "${actualVersion}"
      	}
      }
    '';
  
  # Helper: Generate CUE file for DoD3 negative (missing path)
  # Input: manifest data, self.spec keys, path to remove
  # Output: CUE string with expected (manifest) and actual (missing path)
  genOutputsManifestNegativeCue = manifest: specKeys: missingPath:
    let
      # Expected: from manifest (SSOT)
      expectedPaths = builtins.map (p: ''"${p}"'') manifest.paths;
      expectedPathsList = builtins.concatStringsSep ",\n\t\t\t" expectedPaths;
      
      # Actual: self.spec with one path removed (malicious)
      actualKeysFiltered = builtins.filter (k: k != missingPath) specKeys;
      actualPaths = builtins.map (p: ''"${p}"'') actualKeysFiltered;
      actualPathsList = builtins.concatStringsSep ",\n\t\t\t" actualPaths;
      
      # Version
      expectedVersion = manifest.version;
      actualVersion = self.spec.version or "unknown";
    in ''
      package integration_negative_03
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      
      // Auto-generated by nix/lib/integration.nix
      // Design: expected uses manifest.cue, actual has missing path (malicious)
      
      integrationInput: det.#OutputsManifestInput & {
      	// Expected: manifest.cue (SSOT)
      	expected: {
      		paths: [
      			${expectedPathsList},
      		]
      		version: "${expectedVersion}"
      	}
      	
      	// Actual: self.spec with intentional omission
      	actual: {
      		paths: [
      			${actualPathsList},
      		]
      		version: "${actualVersion}"
      	}
      }
    '';

  # DoD1: Responsibility validation functions
  # Purpose: Generate CUE for responsibility violation detection
  
  # Helper: Generate CUE for responsibility verify (clean feat - no violations)
  # Input: single feat {id, slug}
  # Output: CUE string with feat definition (no forbidden fields)
  genResponsibilityVerifyCue = feat:
    ''
      package integration_verify_01
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      
      // Auto-generated by nix/lib/integration.nix
      // Source: spec/urn/feat/${feat.slug} (real data, clean)
      
      integrationInput: det.#ResponsibilityInput & {
      	feat: {
      		id: "${feat.id}"
      		slug: "${feat.slug}"
      		// Note: Real feats don't have forbidden fields
      		// (contractOverride, schemaOverride, exportOverride)
      	}
      }
    '';
  
  # Helper: Generate CUE for responsibility negative (inject forbidden field)
  # Input: single feat {id, slug}
  # Output: CUE string with feat + contractOverride injection
  genResponsibilityNegativeCue = feat:
    ''
      package integration_negative_01
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      
      // Auto-generated by nix/lib/integration.nix
      // Malicious: Inject contractOverride (forbidden)
      
      integrationInput: det.#ResponsibilityInput & {
      	feat: {
      		id: "${feat.id}"
      		slug: "${feat.slug}"
      		
      		// Malicious injection: contractOverride (forbidden field)
      		contractOverride: {
      			maliciousRule: "this violates responsibility contract"
      		}
      	}
      }
    '';

in {
  inherit 
    listFeatDirs
    extractFeatMeta
    extractAllFeats
    genFeatListVerifyCue
    genFeatListNegativeCue
    extractSpecKeys
    genConsumerAPIVerifyCue
    genConsumerAPINegativeCue
    extractManifest
    genOutputsManifestVerifyCue
    genOutputsManifestNegativeCue
    genResponsibilityVerifyCue
    genResponsibilityNegativeCue;
  
  # Expose CUE module utils
  inherit (cueModule) moduleName importPrefix mkImport;
}
