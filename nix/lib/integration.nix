# Integration test utilities for Phase 6 (Integration-RED)
# Purpose: Extract real data from spec-repo (feats, spec keys, etc.) and generate CUE files
# Design: Nix-only (no shell logic), uses builtins.readDir / cue eval for extraction

{ pkgs, self, cue }:

let
  # Import CUE module utilities
  cueModule = import ./cue-module.nix { inherit pkgs self; };
  
  # Helper: List all feat directories
  # Returns: [ "spec", "decide-ci-score-matrix", ... ]
  listFeatDirs = 
    let
      featRoot = "${self}/spec/urn/feat";
      entries = builtins.readDir featRoot;
      # Filter only directories
      dirs = builtins.filter 
        (name: entries.${name} == "directory")
        (builtins.attrNames entries);
    in dirs;
  
  # Helper: Extract feat metadata (id, slug) from a feat directory
  # Input: feat directory name (e.g., "spec")
  # Output: { id = "urn:feat:spec"; slug = "spec"; }
  extractFeatMeta = featDir:
    let
      # Path to feature.cue
      featFile = "${self}/spec/urn/feat/${featDir}/feature.cue";
      
      # Use CUE to evaluate and extract to JSON
      # Note: This requires CUE eval, which we'll do via derivation
      # For now, we'll use a simple pattern match on slug
      # (id is derived as "urn:feat:<slug>")
      
      # Read feature.cue content
      content = builtins.readFile featFile;
      
      # Extract slug using regex
      # Pattern: slug: "..."
      slugMatch = builtins.match ".*slug:[[:space:]]*\"([^\"]+)\".*" content;
      
      slug = 
        if slugMatch != null && builtins.length slugMatch > 0
        then builtins.head slugMatch
        else throw "Failed to extract slug from ${featFile}";
      
      id = "urn:feat:${slug}";
    in {
      inherit id slug;
    };
  
  # Helper: Extract all feats as list of {id, slug}
  # Returns: [ { id = "urn:feat:spec"; slug = "spec"; } ... ]
  extractAllFeats =
    let
      featDirs = listFeatDirs;
      feats = builtins.map extractFeatMeta featDirs;
    in feats;
  
  # Helper: Generate CUE file content for feat list (verify - clean data)
  # Input: list of {id, slug}
  # Output: CUE string defining feat list (no duplicates)
  # Note: Uses 'integrationInput' to avoid CUE scope resolution issues with 'input: input'
  genFeatListVerifyCue = feats:
    let
      # Convert to CUE list format
      featItems = builtins.map (feat: ''
        {
          id: "${feat.id}"
          slug: "${feat.slug}"
        }'') feats;
      
      # Join with commas
      featList = builtins.concatStringsSep ",\n\t\t" featItems;
    in ''
      package integration_verify_04
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Source: spec/urn/feat/* (real data, clean)
      
      integrationInput: det.#UniqInput & {
      	feats: [
      		${featList},
      	]
      	
      	// Sanity guard: Ensure real data is flowing (minimum 2 feats expected)
      	feats: list.MinItems(2)
      }
    '';
  
  # Helper: Generate CUE file with duplicate feat (for DoD4-Negative)
  # Input: list of {id, slug}
  # Output: CUE string with first feat duplicated (malicious injection)
  # Note: Uses 'integrationInput' to avoid scope issues
  genFeatListNegativeCue = feats:
    let
      # Add duplicate of first feat (malicious)
      duplicate = builtins.head feats;
      featsWithDup = feats ++ [ duplicate ];
      
      featItems = builtins.map (feat: ''
        {
          id: "${feat.id}"
          slug: "${feat.slug}"
        }'') featsWithDup;
      
      featList = builtins.concatStringsSep ",\n\t\t" featItems;
      
      # Extract first feat ID for expected value
      firstFeatId = (builtins.head feats).id;
      firstFeatSlug = (builtins.head feats).slug;
    in ''
      package integration_negative_04
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Source: spec/urn/feat/* + intentional duplicate (malicious injection)
      
      integrationInput: det.#UniqInput & {
      	feats: [
      		${featList},
      	]
      	
      	// Sanity guard: Ensure duplicate was injected (minimum 3 items)
      	feats: list.MinItems(3)
      }
    '';
  
  # Helper: Extract spec keys as flattened dotted paths (for DoD2 Consumer API)
  # Input: self.spec attrset
  # Output: [ "spec.cuePath" "spec.schemaPath" "spec.urn.featPath" ... ]
  # Note: Flattens nested attrs with dot notation, prefixed with "spec."
  extractSpecKeys = spec:
    let
      # Check if value is a derivation (has 'type' = "derivation")
      isDerivation = value:
        builtins.isAttrs value && (value.type or null) == "derivation";
      
      # Flatten nested attrset to dotted paths
      flattenAttrs = prefix: attrs:
        builtins.concatMap (key:
          let
            value = attrs.${key};
            newPrefix = if prefix == "" then key else "${prefix}.${key}";
          in
            if builtins.isAttrs value && !(isDerivation value)
            then flattenAttrs newPrefix value
            else [ newPrefix ]
        ) (builtins.attrNames attrs);
      
      # Start with "spec." prefix
      paths = flattenAttrs "spec" spec;
    in paths;
  
  # Helper: Generate CUE file for DoD2 verify (clean data)
  # Input: list of spec keys (e.g., ["spec.cuePath", ...])
  # Output: CUE string with required (SSOT) and actual (self.spec)
  # Design: required uses detector SSOT, actual uses real data
  genConsumerAPIVerifyCue = specKeys:
    let
      # Actual: real data from self.spec
      actualItems = builtins.map (key: ''"${key}"'') specKeys;
      actualList = builtins.concatStringsSep ",\n\t\t" actualItems;
    in ''
      package integration_verify_02
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Design: required uses detector SSOT, actual uses self.spec (real data)
      
      integrationInput: det.#ConsumerAPIInput & {
      	// Required: SSOT from detector (minimum API contract)
      	required: det.#ConsumerAPIMinimumKeys
      	
      	// Actual: self.spec keys (real implementation)
      	actual: [
      		${actualList},
      	]
      	
      	// Sanity guard: Ensure real data is flowing
      	actual: list.MinItems(6)
      }
    '';
  
  # Helper: Generate CUE file for DoD2 negative (missing key)
  # Input: list of spec keys, key to remove (e.g., "spec.urn.envPath")
  # Output: CUE string with required (SSOT) and actual (missing key)
  # Design: required uses detector SSOT, actual has intentional omission
  genConsumerAPINegativeCue = specKeys: missingKey:
    let
      # Actual: all keys except missingKey (malicious injection)
      actualKeys = builtins.filter (key: key != missingKey) specKeys;
      actualItems = builtins.map (key: ''"${key}"'') actualKeys;
      actualList = builtins.concatStringsSep ",\n\t\t" actualItems;
    in ''
      package integration_negative_02
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      import "list"
      
      // Auto-generated by nix/lib/integration.nix
      // Design: required uses detector SSOT, actual has intentional missing key
      
      integrationInput: det.#ConsumerAPIInput & {
      	// Required: SSOT from detector (minimum API contract)
      	required: det.#ConsumerAPIMinimumKeys
      	
      	// Actual: self.spec keys with intentional omission (malicious)
      	actual: [
      		${actualList},
      	]
      	
      	// Sanity guard: Ensure missing key was injected
      	actual: list.MinItems(5)
      }
    '';

in {
  inherit 
    listFeatDirs
    extractFeatMeta
    extractAllFeats
    genFeatListVerifyCue
    genFeatListNegativeCue
    extractSpecKeys
    genConsumerAPIVerifyCue
    genConsumerAPINegativeCue;
  
  # Expose CUE module utils
  inherit (cueModule) moduleName importPrefix mkImport;
}
