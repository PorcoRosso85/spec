# Integration test utilities for Phase 6 (Integration-RED)
# Purpose: Extract real data from spec-repo (feats, spec keys, etc.) and generate CUE files
# Design: Nix-only (no shell logic), uses builtins.readDir / cue eval for extraction

{ pkgs, self, cue }:

let
  # Import CUE module utilities
  cueModule = import ./cue-module.nix { inherit pkgs self; };
  
  # Helper: List all feat directories
  # Returns: [ "spec", "decide-ci-score-matrix", ... ]
  listFeatDirs = 
    let
      featRoot = "${self}/spec/urn/feat";
      entries = builtins.readDir featRoot;
      # Filter only directories
      dirs = builtins.filter 
        (name: entries.${name} == "directory")
        (builtins.attrNames entries);
    in dirs;
  
  # Helper: Extract feat metadata (id, slug) from a feat directory
  # Input: feat directory name (e.g., "spec")
  # Output: { id = "urn:feat:spec"; slug = "spec"; }
  extractFeatMeta = featDir:
    let
      # Path to feature.cue
      featFile = "${self}/spec/urn/feat/${featDir}/feature.cue";
      
      # Use CUE to evaluate and extract to JSON
      # Note: This requires CUE eval, which we'll do via derivation
      # For now, we'll use a simple pattern match on slug
      # (id is derived as "urn:feat:<slug>")
      
      # Read feature.cue content
      content = builtins.readFile featFile;
      
      # Extract slug using regex
      # Pattern: slug: "..."
      slugMatch = builtins.match ".*slug:[[:space:]]*\"([^\"]+)\".*" content;
      
      slug = 
        if slugMatch != null && builtins.length slugMatch > 0
        then builtins.head slugMatch
        else throw "Failed to extract slug from ${featFile}";
      
      id = "urn:feat:${slug}";
    in {
      inherit id slug;
    };
  
  # Helper: Extract all feats as list of {id, slug}
  # Returns: [ { id = "urn:feat:spec"; slug = "spec"; } ... ]
  extractAllFeats =
    let
      featDirs = listFeatDirs;
      feats = builtins.map extractFeatMeta featDirs;
    in feats;
  
  # Helper: Generate CUE file content for feat list (verify - clean data)
  # Input: list of {id, slug}
  # Output: CUE string defining feat list (no duplicates)
  genFeatListVerifyCue = feats:
    let
      # Convert to CUE list format
      featItems = builtins.map (feat: ''
        {
          id: "${feat.id}"
          slug: "${feat.slug}"
        }'') feats;
      
      # Join with commas
      featList = builtins.concatStringsSep ",\n\t\t" featItems;
    in ''
      package integration_verify_04
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      
      // Auto-generated by nix/lib/integration.nix
      // Source: spec/urn/feat/* (real data, clean)
      
      input: det.#UniqInput & {
      	feats: [
      		${featList},
      	]
      }
    '';
  
  # Helper: Generate CUE file with duplicate feat (for DoD4-Negative)
  # Input: list of {id, slug}
  # Output: CUE string with first feat duplicated (malicious injection)
  genFeatListNegativeCue = feats:
    let
      # Add duplicate of first feat (malicious)
      duplicate = builtins.head feats;
      featsWithDup = feats ++ [ duplicate ];
      
      featItems = builtins.map (feat: ''
        {
          id: "${feat.id}"
          slug: "${feat.slug}"
        }'') featsWithDup;
      
      featList = builtins.concatStringsSep ",\n\t\t" featItems;
    in ''
      package integration_negative_04
      
      import det "github.com/porcorosso85/spec-repo/spec/ci/detector"
      
      // Auto-generated by nix/lib/integration.nix
      // Source: spec/urn/feat/* + intentional duplicate (malicious injection)
      
      input: det.#UniqInput & {
      	feats: [
      		${featList},
      	]
      }
    '';

in {
  inherit 
    listFeatDirs
    extractFeatMeta
    extractAllFeats
    genFeatListVerifyCue
    genFeatListNegativeCue;
  
  # Expose CUE module utils
  inherit (cueModule) moduleName importPrefix mkImport;
}
